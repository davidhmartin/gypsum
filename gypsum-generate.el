;;; gypsum-generate.el --- Theme file generation for Gypsum -*- lexical-binding: t; -*-

;; Copyright (C) 2025

;; Author: David Martin
;; Keywords: faces, themes

;; This file is part of Gypsum.

;;; Commentary:

;; Generates Emacs theme files from palettes and face specifications.
;; Produces complete, self-contained `-theme.el' files that can be
;; loaded with `load-theme'.
;;
;; The main entry point is `gypsum-generate-from-palette' which takes
;; a complete palette plist and generates a theme file.

;;; Code:

(require 'gypsum-palette)
(require 'gypsum-faces)

;;; --- Configuration ---

(defcustom gypsum-output-directory
  custom-theme-directory
  "Default directory for generated theme files.
Defaults to `custom-theme-directory', which is already in
`custom-theme-load-path' so generated themes are immediately
available via `load-theme'."
  :type 'directory
  :group 'gypsum)

(defcustom gypsum-author-name nil
  "Author name to include in generated theme headers.
If nil, uses \"Generated by Gypsum\"."
  :type '(choice (const nil) string)
  :group 'gypsum)

;;; --- Color to Variable Mapping ---

(defvar gypsum-generate--color-map nil
  "Alist mapping hex colors to variable names during generation.")

(defun gypsum-generate--build-color-map (palette)
  "Build color map from PALETTE for variable substitution."
  (cl-loop for (key value) on palette by #'cddr
           when (stringp value)
           collect (cons (upcase value)
                         (substring (symbol-name key) 1))))

(defun gypsum-generate--color-to-var (color)
  "Get variable name for COLOR, or return color if not in map."
  (if (and (stringp color) (string-prefix-p "#" color))
      (or (cdr (assoc (upcase color) gypsum-generate--color-map))
          color)
    color))

;;; --- Theme File Header ---

(defun gypsum-generate--header (name palette)
  "Generate the file header for theme NAME with PALETTE."
  (let ((variant (plist-get palette :variant))
        (definition (plist-get palette :definition))
        (author (or gypsum-author-name "Generated by Gypsum")))
    (format ";;; %s-theme.el --- %s theme for Emacs -*- lexical-binding: t; -*-

;; Author: %s
;; URL: https://github.com/davidhmartin/gypsum
;; Version: 1.0.0
;; Package-Requires: ((emacs \"24.1\"))
;; Keywords: faces, theme, minimal

;; This file is not part of GNU Emacs.

;;; Commentary:

;; %s is a minimalist syntax highlighting theme, which only highlights four categories:
;; 1. Strings (green) - including regexps and symbols
;; 2. Constants (magenta) - numbers, booleans, language constants
;; 3. Comments (red) - prominently, NOT dimmed
;; 4. Global definitions (blue) - function/class/variable definitions
;;
;; Everything else (keywords, operators, punctuation, variables) uses the
;; default foreground color.
;;
;; Key principles:
;; - Keywords are NOT highlighted - they are the least important part
;; - Comments should be prominent - if someone wrote it, you should read it
;; - No font variations - no bold, no italics, just color
;; - Minimal palette - few enough colors to memorize what each means
;;
;; Based on Nikita Tonsky's Alabaster: https://tonsky.me/blog/syntax-highlighting/
;;
;; Variant: %s
;; Seed color: %s

;;; Code:

"
            name
            (capitalize (format "%s" name))
            author
            (capitalize (format "%s" name))
            variant
            definition)))

(defun gypsum-generate--deftheme (name palette)
  "Generate the deftheme form for theme NAME with PALETTE."
  (let ((variant (plist-get palette :variant)))
    (format "(deftheme %s
  \"%s - A minimalist theme that highlights what matters.
Only strings, constants, comments, and definitions get color.\")\n\n"
            name
            (capitalize (format "%s %s" name variant)))))

;;; --- Palette Embedding for Discovery ---

(defun gypsum-generate--palette-defconst (name palette)
  "Generate defconst forms for NAME embedding PALETTE.
These constants allow the theme to be discovered and reused as a source
for generating new themes."
  (format "(defconst %s-gypsum-generated t
  \"Non-nil indicates this theme was generated by Gypsum.
This marker enables automatic discovery of gypsum themes.\")

(defconst %s-gypsum-palette
  '%S
  \"The Gypsum palette used to generate this theme.
Can be used as a starting point for new themes.\")

"
          name name palette))

;;; --- Color Variable Bindings ---

(defun gypsum-generate--palette-let (palette)
  "Generate the let bindings for PALETTE colors."
  (let ((bindings '()))
    (push "(class '((class color) (min-colors 89)))" bindings)
    ;; Add comment explaining color palette structure
    (push ";; Color palette" bindings)
    ;; Background colors
    (dolist (key '(:background :bg-alt))
      (let ((value (plist-get palette key)))
        (when (stringp value)
          (push (format "(%s %S)"
                        (substring (symbol-name key) 1)
                        value)
                bindings))))
    ;; Foreground colors
    (dolist (key '(:foreground :fg-dim))
      (let ((value (plist-get palette key)))
        (when (stringp value)
          (push (format "(%s %S)"
                        (substring (symbol-name key) 1)
                        value)
                bindings))))
    ;; Core highlighting - the four categories
    (push ";; Core highlighting - the only four categories" bindings)
    (dolist (key '(:string :constant :comment :definition))
      (let ((value (plist-get palette key))
            (comment (pcase key
                       (:string "green - strings, regexps, symbols")
                       (:constant "magenta - numbers, booleans, constants")
                       (:comment "red - comments (prominent!)")
                       (:definition "blue - function/class/var definitions"))))
        (when (stringp value)
          (push (format "(%s %S)   ; %s"
                        (substring (symbol-name key) 1)
                        value
                        comment)
                bindings))))
    ;; UI colors
    (push ";; UI colors" bindings)
    (dolist (key '(:selection :highlight :find-hl))
      (let ((value (plist-get palette key)))
        (when (stringp value)
          (push (format "(%s %S)"
                        (substring (symbol-name key) 1)
                        value)
                bindings))))
    ;; Status colors
    (push ";; Status colors" bindings)
    (dolist (key '(:error :warning :success))
      (let ((value (plist-get palette key)))
        (when (stringp value)
          (push (format "(%s %S)"
                        (substring (symbol-name key) 1)
                        value)
                bindings))))
    ;; Diff colors
    (push ";; Diff colors" bindings)
    (dolist (key '(:diff-add-bg :diff-del-bg :diff-chg-bg))
      (let ((value (plist-get palette key)))
        (when (stringp value)
          (push (format "(%s %S)"
                        (substring (symbol-name key) 1)
                        value)
                bindings))))
    ;; Terminal colors
    (push ";; Terminal colors (ANSI 16-color palette)" bindings)
    (dolist (key '(:term-black :term-red :term-green :term-yellow
                   :term-blue :term-magenta :term-cyan :term-white
                   :term-bright-black :term-bright-red :term-bright-green
                   :term-bright-yellow :term-bright-blue :term-bright-magenta
                   :term-bright-cyan :term-bright-white))
      (let ((value (plist-get palette key)))
        (when (stringp value)
          (push (format "(%s %S)"
                        (substring (symbol-name key) 1)
                        value)
                bindings))))
    (concat "(let (" (mapconcat #'identity (nreverse bindings) "\n      ") ")\n\n")))

;;; --- Face Formatting ---

(defun gypsum-generate--format-value (value)
  "Format VALUE for theme output, using variable references for colors."
  (cond
   ;; Hex color -> variable reference
   ((and (stringp value) (string-prefix-p "#" value))
    (let ((var (gypsum-generate--color-to-var value)))
      (if (string-prefix-p "#" var)
          (format "%S" var)  ; No mapping, use literal
        (format ",%s" var))))
   ;; Boolean
   ((eq value t) "t")
   ((eq value nil) "nil")
   ;; Number
   ((numberp value) (number-to-string value))
   ;; Symbol
   ((symbolp value) (symbol-name value))
   ;; Other
   (t (format "%S" value))))

(defun gypsum-generate--format-box (box-spec)
  "Format BOX-SPEC for theme output."
  (if (and (listp box-spec) (plist-get box-spec :line-width))
      (let ((width (plist-get box-spec :line-width))
            (color (plist-get box-spec :color)))
        (format "(:line-width %d :color %s)"
                width
                (gypsum-generate--format-value color)))
    (format "%S" box-spec)))

(defun gypsum-generate--format-underline (underline-spec)
  "Format UNDERLINE-SPEC for theme output."
  (cond
   ((eq underline-spec t) "t")
   ((null underline-spec) "nil")
   ((and (listp underline-spec) (plist-get underline-spec :style))
    (let ((style (plist-get underline-spec :style))
            (color (plist-get underline-spec :color)))
      (format "(:style %s :color %s)"
              style
              (gypsum-generate--format-value color))))
   (t (format "%S" underline-spec))))

(defun gypsum-generate--format-face-attrs (attrs)
  "Format face ATTRS plist for theme output."
  (let ((parts '()))
    (cl-loop for (key value) on attrs by #'cddr do
             (let ((formatted-value
                    (pcase key
                      (:box (gypsum-generate--format-box value))
                      (:underline (gypsum-generate--format-underline value))
                      (_ (gypsum-generate--format-value value)))))
               (push (format "%s %s" key formatted-value) parts)))
    (concat "(" (mapconcat #'identity (nreverse parts) " ") ")")))

(defun gypsum-generate--format-face-spec (face-spec)
  "Format a single FACE-SPEC for theme output.
FACE-SPEC is (FACE-NAME ((CLASS ATTRS)))."
  (let* ((face-name (car face-spec))
         (class-specs (cadr face-spec))
         (attrs (cadr (car class-specs))))
    (format "   `(%s ((,class %s)))"
            face-name
            (gypsum-generate--format-face-attrs attrs))))

;;; --- Section Comments ---

(defconst gypsum-generate--face-sections
  '((default . "=== Basic faces ===")
    (font-lock-string-face . "=== Font-lock faces - THE CORE OF ALABASTER ===")
    (mode-line . "=== Mode line ===")
    (minibuffer-prompt . "=== Minibuffer ===")
    (isearch . "=== Search ===")
    (link . "=== Links ===")
    (error . "=== Status ===")
    (line-number . "=== Line numbers ===")
    (show-paren-match . "=== Parens ===")
    (diff-added . "=== Diff ===")
    (completions-common-part . "=== Completions ===")
    (org-level-1 . "=== Org mode ===")
    (markdown-header-face . "=== Markdown mode ===")
    (flycheck-error . "=== Flycheck / Flymake ===")
    (company-tooltip . "=== Company mode ===")
    (corfu-default . "=== Corfu ===")
    (vertico-current . "=== Vertico ===")
    (magit-section-heading . "=== Magit ===")
    (git-gutter:added . "=== Git gutter ===")
    (dired-directory . "=== Dired ===")
    (eshell-prompt . "=== Eshell ===")
    (term-color-black . "=== Terminal / VTerm ===")
    (avy-lead-face . "=== Avy ===")
    (tree-sitter-hl-face:keyword . "=== Tree-sitter ===")
    (web-mode-html-tag-face . "=== Web-mode ==="))
  "Alist mapping face names to section comments.")

(defun gypsum-generate--get-section-comment (face-name)
  "Get section comment for FACE-NAME, if any."
  (cdr (assq face-name gypsum-generate--face-sections)))

;;; --- Footer ---

(defun gypsum-generate--footer (name)
  "Generate the file footer for theme NAME."
  (format "

;;;###autoload
(when load-file-name
  (add-to-list 'custom-theme-load-path
               (file-name-as-directory (file-name-directory load-file-name))))

(provide-theme '%s)

;;; %s-theme.el ends here
" name name))

;;; --- Main Generation Functions ---

(defun gypsum-generate--build-file-content (name palette)
  "Build complete theme file content for NAME with PALETTE."
  (let* ((gypsum-generate--color-map (gypsum-generate--build-color-map palette))
         (face-specs (gypsum-faces-generate palette))
         (output-lines '()))
    ;; Format each face, adding section comments where appropriate
    (dolist (spec face-specs)
      (let* ((face-name (car spec))
             (section (gypsum-generate--get-section-comment face-name)))
        (when section
          (push (format "\n   ;; %s" section) output-lines))
        (push (gypsum-generate--format-face-spec spec) output-lines)))
    (concat
     (gypsum-generate--header name palette)
     (gypsum-generate--deftheme name palette)
     (gypsum-generate--palette-defconst name palette)
     (gypsum-generate--palette-let palette)
     "  (custom-theme-set-faces\n"
     (format "   '%s\n" name)
     (mapconcat #'identity (nreverse output-lines) "\n")
     "))"
     (gypsum-generate--footer name))))

(defun gypsum-generate-from-palette (name palette &optional output load)
  "Generate a theme file with NAME from PALETTE.

Arguments:
  NAME    - Theme name (string, no -theme suffix)
  PALETTE - Complete palette plist
  OUTPUT  - Output file path (optional)
  LOAD    - Load and enable after generation (default t)

Returns the path to the generated theme file."
  ;; Validate name
  (when (string-suffix-p "-theme" name)
    (setq name (substring name 0 -6)))
  (when (string-empty-p name)
    (error "Theme name cannot be empty"))
  ;; Validate palette
  (gypsum-palette-validate palette)
  ;; Default load to t
  (when (null load)
    (setq load t))
  (let* ((output-path (or output
                          (expand-file-name
                           (format "%s-theme.el" name)
                           gypsum-output-directory)))
         (content (gypsum-generate--build-file-content name palette))
         (theme-sym (intern name)))
    ;; Ensure output directory exists
    (unless (file-directory-p (file-name-directory output-path))
      (make-directory (file-name-directory output-path) t))
    ;; Write file
    (with-temp-file output-path
      (insert content))
    (message "Generated theme: %s" output-path)
    ;; Load and enable if requested
    (when load
      (add-to-list 'custom-theme-load-path (file-name-directory output-path))
      (load-file output-path)
      (load-theme theme-sym t)
      (message "Theme '%s' loaded and enabled" name))
    output-path))

;; Legacy API compatibility
(cl-defun gypsum-generate (name &rest args &key seed variant contrast
                                _background _string _constant _comment
                                _definition output load)
  "Generate a theme file with NAME (legacy API).

This function is provided for backwards compatibility.
Prefer `gypsum-generate-from-palette' for new code.

Arguments:
  NAME              - Theme name (string, no -theme suffix)

Keyword arguments:
  :seed HEXCOLOR    - Base color (becomes definition)
  :variant SYMBOL   - \\='light or \\='dark
  :contrast SYMBOL  - \\='normal (default) or \\='low (ignored in new API)
  :output PATH      - Output file path (optional)
  :load BOOL        - Load and enable after generation (default t)

Returns the path to the generated theme file."
  (declare (obsolete gypsum-generate-from-palette "2.0"))
  (unless seed
    (error "Must provide :seed color"))
  (unless variant
    (error "Must provide :variant"))
  (when (eq contrast 'low)
    (message "Warning: low contrast mode not yet implemented in new API"))
  (let ((palette (gypsum-palette-generate seed variant)))
    (gypsum-generate-from-palette name palette output load)))

(provide 'gypsum-generate)

;;; gypsum-generate.el ends here
